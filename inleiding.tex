%%=============================================================================
%% Inleiding
%%=============================================================================
\chapter{Inleiding}
\label{ch:inleiding}
Het onderzoek zal verschillende methodes voor offline opslag en synchronisatie analyseren en onderzoeken. Het onderzoek zal van elke methode de voor- en nadelen overlopen en de toepassing tonen met behulp van een prototype. In de sectie 'Business Case' wordt de business case van Pridiktiv.care - Into.care toegelicht. Daarna worden in 'Terminologie' de verschillende relevante termen overlopen. In 'Stand van zaken' komt de context en noodzaak van het onderzoek aan bod. Tenslotte volgt de probleemstelling, de onderzoeksvraag en de opzet van de bachelorproef.
%% literatuurstudie. Vergeet niet telkens je bronnen te vermelden!
\section{Business Case}
\label{sec:business-case}
De business case van Pridiktiv vormt het vertrekpunt van deze studie en wordt nu nog wat verder toegelicht. De applicatie draait op een smartphone in een woonzorgcentrum. Het woonzorgcentrum beschikt over draadloos internet maar het gebouw is niet volledig gedekt. Dus moet de applicatie ook offline werken. Wanneer verschillende waarden worden geregistreerd met de applicatie (zoals bloeddruk, gewicht, inname medicatie) worden die offline opgeslagen in een IndexedDB. Wanneer het toestel terug online komt, moeten deze waarden worden doorgestuurd naar de backend. Het is essentieel dat er geen data verloren gaat aangezien het gaat om medische data. Het huidige algoritme doet een HTTP call wanneer een waarde wordt ingegeven. Wanneer dit niet lukt, veronderstelt het algoritme dat de applicatie offline is en worden de data lokaal opgeslagen. Wanneer het toestel terug online komt, dan worden de offline data gesynchroniseerd met de server. De realiteit wijst echter uit dat betrouwbaar internet eerder uitzonderlijk is in een woonzorgcentrum. In deze context is er dus nood aan een 'offline first' -  oplossing. De huidige applicatie is een Angular (het vroegere Angular 2) met Ngrx als state container als een Cordova applicatie. Voor lokale opslag wordt momenteel gebruik gemaakt van Mozilla's localForage library. De backend maakt gebruik van Amazon Web Services met DynamoDB voor de persistentie van de data. Het is de intentie van dit onderzoek om te werken binnen het kader en binnen de restricties van de business case.
\section{Terminologie}
\label{sec:terminologie}
In deze sectie komen de verschillende begrippen met betrekking tot de componenten van het onderzoek, het prototype en tools aan bod. De volledige lijst met begrippen en termen kan u terugvinden onder het hoofdstuk 'Glossarium'. Er is een minimum kennis in verband met software ontwikkeling vereist van de lezer om deze sectie volledig te begrijpen.
\subsection{Huidige Web APIs voor lokale opslag}
Er zijn momenteel 4 APIs voor lokale opslag die ondersteund worden door verschillende browsers. Deze APIs worden ondersteund door de Web Hypertext Application Technology Working Group, aangegeven door WHATWG en de specificatie van de API wordt dan gestandardiseerd door het World Wide Web Consortium, aangegeven door W3C. Dit proces is belangrijk omdat de APIs dan door de populaire browsers (Chrome, Firefox, Safari en Opera, Internet Explorer en Edge) worden ge\"integreerd. Op die manier kunnen webapplicaties gebruik maken van de verschillende APIs. Het is belangrijk om deze APIs kort te overlopen omdat ze steeds gebruikt worden bij de verschillende caching technieken om data lokaal op te slaan.
\subsubsection{localStorage en sessionStorage}
Deze 2 APIs vallen onder Web Storage of DOM Storage. Wanneer de browser ondersteuning biedt voor Web Storage, zijn beide beschikbaar als een globaal object. Web Storage wordt vaak vergeleken met cookies. Terwijl die vergelijkbaar zijn in functie, verschilt web storage in volgende aspecten: 
\begin{itemize}  
\item Opslag ruimte: Afhankelijk van browser maar meestal 5 MB beschikbare opslagruimte in vergelijking met maar 4 kb voor cookies.
\item Client-side interface: Cookies kunnen zowel door server als client side worden gebruikt. Web storage valt exclusief onder client-side scripting.
\item Twee verschillende storage areas: localStorage en sessionStorage.
\item Een eenvoudigere programmeerbare interface in vergelijking met cookies.
\end{itemize}
\subsubsection{localStorage}
Data die in localStorage wordt opgeslagen is persistent tenzij die manueel wordt verwijderd door de gebruiker of applicatie. localStorage is dus een belangrijke kandidaat om data lokaal op te slaan in geval een applicatie offline moet kunnen worden gebruikt. Bij gevoelige data zoals medische data is het belangrijk om de data te verwijderen uit de localStorage wanneer die niet meer moet worden gecached.
\subsubsection{sessionStorage}
Het grote verschil met localStorage is dat sessionStorage een vervalttijd heeft en de inhoud van de sessionStorage wordt verwijderd wanneer de sessie vervalt. Een sessie vervalt bijvoorbeeld hij het openen van een nieuw tabblad of browser venster. Refreshen van de browser heeft geen impact op de sessionStorage. sessionStorage laat toe om instances van een webapplicatie te runnen in verschillende browser windows, zonder dat er conflicten optreden.
\subsubsection{lndexedDB}
IndexedDB is een Web API die gebruikt wordt het opslaan van relatief grote data structuren in browsers. Dankzij indexering is het mogelijk om snel en performant te zoeken in de databank. Net zoals SQL-databanken is IndexedDB een transactional database system. Het grote verschil is echter het gebruik van JSON objecten in plaats van fixed columns tables om data op te slaan, vergelijkbaar met andere NoSQL databanken zoals MongoDB of CouchDB. Onder impuls van Mozilla wordt IndexedDB waarschijnlijk de alternatieve storage standaard voor het web in de nabije toekomst.
\subsubsection{Web SQL}
Net zoals bij IndexedDB biedt Web SQL toegang tot een databank waar data structuren kunnen worden opgeslagen. Met een SQL variant is het dan mogelijk om queries uit te voeren op de Web SQL database. Momenteel biedt enkel SQLite een database systeem voor Web SQL. W3C werkt momenteel niet meer verder aan de specificatie van Web SQL omdat er te weinig onafhankelijke implementaties zijn van Web SQL. 
\subsection{Scalable Angular Architecture}
Bij de start van de ontwikkeling van een Angular applicatie is het belangrijk om na te denken over de architectuur van de applicatie. Moderne SPA-technologie\"en zoals React en Angular maken gebruik van components. Een component is combinatie van HTML, JavaScript en optioneel CSS. Door alles in componenten onder te verdelen is het eenvoudiger om de applicatie te onderhouden omdat alle relevante data word gegroepeerd. Componenten zelf kunnen 'dumb' zijn als ze enkel data voorstellen of 'smart' wanneer ze data opvragen of verwerken.
De dataflow tussen componenten is ook belangrijk om een beheersbare applicatie te bouwen. Zo communiceren child components enkel maar met hun parent en interageert een parent met een model dat op zijn beurt communiceert met een 'store' (.cfr 'ngrx store: een state container') aan de hand van acties. Wanneer de state wordt gewijzigd in de store, dan wordt de volledige component tree opnieuw ge\"evalueerd. Een ander belangrijk aspect van een scalable SPA is het inperken van de communicatiemogelijkheden van smart components. Door het gebruik van een extra abstractie layer, zoals een model of sandbox, is het mogelijk om de communicatie te verwerken in de abstractielaag en op die manier een microservice te genereren die gemakkelijk kan worden refactored indien er aanpassingen moeten gebeuren.
\subsection{Ngrx store: een state container}
Ngrx store is een container die de state van de applicatie bijhoudt waarbij performantie en consistentie centraal staan. De ngrx store is de 'single source of truth', verder benoemd als SSOT, voor de applicatie en moet ervoor zorgen dat de data van alle componenten consistent is met elkaar en er geen duplicate data is. Alle updates aan de data worden eerste weggeschreven naar de store en daarna gecachet. In het geval dat de gebruiker toegang heeft tot het Internet worden de data verstuurd naar de achterliggende systemen. Indien er geen of slechte internetverbinding is, krijgt de user de gecachte data te zien dankzij de SSOT. De ngrx store werkt met volgende principes:
\begin{itemize}  
\item de state is een single immutable JSON data structure
\item actions initialiseren veranderingen in de state
\item reducers verwerken actions om een 'nieuwe' state te cre\"een. Een reducer is een functie die een action moet verwerken
\item de state van de store wordt geraadpleegd als een Observable van state die op zijn beurt een observer is van actions
\end{itemize}
\subsection{Reactive programming paradigm}
Het reactive programming paradigm is gebouwd rond veranderende data flows, waarbij een applicatie kan reageren op nieuwe of andere input. Dankzij de ReactiveX library is het mogelijk om in verschillende programmeertalen componenten van reactive programming te gebruiken. De library laat toe om asynchroon en event-based applicaties te ontwikkelen, die in real-time data kunnen manipuleren en tonen. Het breidt het Observer design pattern waarbij het mogelijk is om verschillende operators te 'chainen' met elkaar zonder rekening te houden met low level concerns zoals threading, synchronisatie, thread safety, concurrent data structures en blocking I/O. De RxJs library van ReactiveX is volledig ge\"integreerd in Angular en ngrx store. Met Promises was het reeds mogelijk om asynchroon te programmeren in JavaScript dus wat zijn de voordelen van RxJs ten opzicht van standaard JavaScript? Een Promise kan maar een single event afhandelen en kan niet worden gecancelled. Een Observable kan worden beschouwd als een stream van objecten waarop verschillende operatoren zoals map, reduce en filter kunnen worden op toegepast en is lazy van natuur.
\subsection{Offline First}
Een stroming binnen web development waarbij offline gebruik als de basis wordt beschouwd van de applicatie. Net zoals bij 'Progressive Enhancement' wordt online functionaliteit beschouwt als een extra laag van features die de applicatie kan aanbieden. Het idee is gegroeid vanuit de teleurstelling dat 'always online' omwille van technische, geografische, financi\"ele en praktische redenen nog niet haalbaar is voor de nabije toekomst.
\subsection{Amazon Web Services}
Om het onderzoek zo dicht mogelijk te laten aansluiten bij de use case van Pridiktiv, wordt gebruikt gemaakt van bepaalde onderdelen binnen AWS. Volgende componenten komen aan bod in de bachelor paper:
\begin{itemize}
\item Amazon SQS: Simple Queue Service: SQS is een fully managed message queue service die toelaat om te communiceren tussen verschillende componenten en microservices. SQS voorziet 2 varienten. De standard queue biedt de snelste en performantste oplossing maar hanteert geen FIFO-principe. Een FIFO-queue, zoals de naam reeds aangeeft, hanteert wel het FIFO-principe en elke message in de queue wordt altijd maar 1 keer geleverd. Andere AWS services pollen de queue voor nieuwe data.
\item Lambda: Met AWS Lambda is het mogelijk om 'functies' uit te voeren in de cloud dus zonder een specifieke server structuur op te bouwen en vormt dus de basis voor de serverless architectuur. De input voor de functie kan worden geleverd door HTTP endpoints maar ook door andere AWS services en is een voorbeeld van een event-driven architecture. De output kan dan bijvoorbeeld worden gepersisteerd door DynamoDB of teruggestuurd worden naar de client. De verschillende Lambda functies vormen de microservices architecture in de backend.
\item Amazon SNS, Amazon Simple Notification Service: Een push notificatie service die toelaat om berichten te sturen naar mobile clients, email adressen of andere services. Met SNS is het onder andere mogelijk om polling van andere services te vermijden.
\item DynamoDB: DynamoDB is een NoSQL key-value database van AWS en wordt gebruikt door de business case voor de data opslag. DynamoDB voorziet geen automatische synchronisatie met clients.
\item API Gateway: API Gateway is een fully managed service die toelaat om API's te beheren toe toegang bieden tot de backend.
\end{itemize}
\section{Stand van zaken}
\label{sec:stand-van-zaken}
Wanneer een ontwikkelaar de end user van zijn web -of mobiele applicatie wil voorstellen, dan denkt hij vaak aan een user met dezelfde eigenschappen als zichzelf (laatste smartphone, up-to-date besturingssysteem,  snelle internet verbinding). De ontwikkelomgeving (snelle desktop/laptop met een betrouwbare en snelle internet verbinding) simuleert amper de omgeving van de eindgebruiker. Bepaalde omgevingsfactoren zoals tunnels, trein en vliegtuig hebben een grote invloed op de betrouwbaarheid van de connectie. Het klassieke client - server model waarbij de client enkel maar als het ware een view is van de data die door de server worden bijgehouden, is achterhaald, want elke onderbreking in de internetconnectie zorgt ervoor dat de applicatie niet meer kan worden gebruikt. Meeste mobiele- en webapplicaties hebben twee momenten waarbij er problemen kunnen optreden door de status van de connectie:
\begin{enumerate}  
\item client push request naar de server
\item client pull van server / server push naar client
\end{enumerate}
Afhankelijk wat de applicatie wil doen, zijn er verschillende opties:
\begin{itemize}  
\item De gebruiker al dan niet op de hoogte brengen van de veranderingen in de status van de connectie. Bijvoorbeeld: Bij het versturen van bericht, de gebruiker op de hoogte brengen dat het bericht pas wordt verstuurd wanneer de applicatie terug online is.
\item Offline client-side creatie en manipulatie van data toelaten aan de hand van caching en wanneer de applicatie terug online, deze data synchroniseren met de remote database.
\item Uitschakelen of aanpassen van bepaalde features wanneer de applicatie offline is.
\end{itemize}
Daarnaast is het mogelijk dat de server data wil pushen naar de applicatie van de gebruiker en dat deze verschillen met de data van de applicatie. De applicatie moet de gebruiker dan waarschuwen dat er nieuwere, recentere data beschikbaar zijn en indien nodig, een conflict-resolution tool aanbieden.
Momenteel zijn er al enkele frameworks en databank systemen die eenvoudig toelaten om (offline) data te synchroniseren van een web- of mobiele applicatie met de achterliggende databank. CloudBoost, CouchBase en Firebase bieden een all-in-one oplossing. Het nadeel van die oplossing is dat het niet compatibel is met de bestaande backend. Deze opties komen dan ook niet verder aan bod in dit  onderzoek.
%% TODO: deze sectie (die je kan opsplitsen in verschillende secties) bevat je
\section{Probleemstelling en Onderzoeksvragen}
\label{sec:onderzoeksvragen}
Het doel van dit onderzoek is om bij een bestaande Angular applicatie data synchronisatie zo vlot mogelijk te laten verlopen, zonder onderbreking bij de gebruiker terwijl de data consistent blijft. Hoe wordt conflict-resolution opgelost en moet de gebruiker daar zelf een keuze maken of kan de applicatie of achterliggende systemen zelf alle conflicten oplossen? Tenslotte wordt ook de performantie en de schaalbaarheid van de oplossingen onderzocht. Op basis van verschillende tests op het prototype, is de intentie van het onderzoek om tot een betrouwbare oplossing te komen voor het probleem van de business case. Zoals reeds vermeld moet in het geval van de business case, de applicatie zonder onderbreking gemakkelijk kunnen overstappen van een offline status naar een online status en omgekeerd, zonder dat er daarbij belangrijke data verloren gaat. Het is cruciaal dat deze functionaliteit wordt verwerkt aangezien de dekking van draadloos internet in verschillende woonzorgcentra niet optimaal is.
%% TODO:
%% Uit je probleemstelling moet duidelijk zijn dat je onderzoek een meerwaarde
%% heeft voor een concrete doelgroep (bv. een bedrijf).
%%
%% Wees zo concreet mogelijk bij het formuleren van je
%% onderzoeksvra(a)g(en). Een onderzoeksvraag is trouwens iets waar nog
%% niemand op dit moment een antwoord heeft (voor zover je kan nagaan).

\section{Opzet van deze bachelorproef}
\label{sec:opzet-bachelorproef}

%% TODO: Het is gebruikelijk aan het einde van de inleiding een overzicht te
%% geven van de opbouw van de rest van de tekst. Deze sectie bevat al een aanzet
%% die je kan aanvullen/aanpassen in functie van je eigen tekst.

De rest van deze bachelorproef is als volgt opgebouwd:

In het volgende hoofdstuk ~\ref{ch:methodologie} wordt de methodologie toegelicht die werd gehanteerd voor dit onderzoek. Het gebruikte prototype en backend infrastructuur voor dit onderzoek wordt toegelicht in hoofdstuk ~\ref{ch:setup}. Het onderzoek start in hoofdstuk~\ref{ch:synchronisatiemethdodes} met een opsomming van verschillende synchronisatieoplossingen. In hoofdstuk~\ref{ch:onderzoek} worden de oplossingen op de verschillende problemen bij synchronisatie overlopen. Tenslotte kan u in hoofdstuk~\ref{ch:conclusie} de conclusie en een oplossing vinden. Daarbij wordt ook een aanzet gegeven voor toekomstig onderzoek binnen dit domein.
Indien bepaalde begrippen onduidelijk zijn, vindt u een beknopte uitleg in het het hoofdstuk~\ref{ch:glossarium}.
%% TODO: Vul hier aan voor je eigen hoofstukken, één of twee zinnen per hoofdstuk


